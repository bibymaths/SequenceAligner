{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"SequenceAligner Documentation \u00b6 Overview \u00b6 SequenceAligner is a lightweight C++ tool designed for the comparative alignment of biological sequences. It supports three classic algorithms: Longest Common Subsequence (LCS) : Identifies the longest sequence of characters that appear left-to-right (not necessarily contiguously) in both sequences. Global Alignment (Needleman-Wunsch) : Finds the best full-length alignment between two sequences using dynamic programming. Local Alignment (Smith-Waterman) : Identifies the highest scoring local subsequence alignment useful for identifying conserved motifs. This tool is optimized for command-line use with FASTA inputs and outputs colorful visual feedback. Command-Line Usage \u00b6 Usage \u00b6 ./aligner --query <query.fasta> --target <target.fasta> --choice <1|2|3|4> [--mode dna|protein] [--outdir <directory>] [--verbose] Where: \u00b6 --query specifies the first input FASTA file. --target specifies the second input FASTA file. --choice selects the alignment method: 1 = global 2 = local 3 = LCS 4 = all methods --mode (optional) sets scoring mode: dna (default) or protein . --outdir (optional) sets the output directory (default is current directory). --verbose (optional) enables progress and detailed output. Please refer to API Documentation","title":"Home"},{"location":"index.html#sequencealigner-documentation","text":"","title":"SequenceAligner Documentation"},{"location":"index.html#overview","text":"SequenceAligner is a lightweight C++ tool designed for the comparative alignment of biological sequences. It supports three classic algorithms: Longest Common Subsequence (LCS) : Identifies the longest sequence of characters that appear left-to-right (not necessarily contiguously) in both sequences. Global Alignment (Needleman-Wunsch) : Finds the best full-length alignment between two sequences using dynamic programming. Local Alignment (Smith-Waterman) : Identifies the highest scoring local subsequence alignment useful for identifying conserved motifs. This tool is optimized for command-line use with FASTA inputs and outputs colorful visual feedback.","title":"Overview"},{"location":"index.html#command-line-usage","text":"","title":"Command-Line Usage"},{"location":"index.html#usage","text":"./aligner --query <query.fasta> --target <target.fasta> --choice <1|2|3|4> [--mode dna|protein] [--outdir <directory>] [--verbose]","title":"Usage"},{"location":"index.html#where","text":"--query specifies the first input FASTA file. --target specifies the second input FASTA file. --choice selects the alignment method: 1 = global 2 = local 3 = LCS 4 = all methods --mode (optional) sets scoring mode: dna (default) or protein . --outdir (optional) sets the output directory (default is current directory). --verbose (optional) enables progress and detailed output. Please refer to API Documentation","title":"Where:"},{"location":"about.html","text":"About This Project \u00b6 This tool was first written by Abhinav Mishra during a Biological Computation course at JUIT, Solan in 2014. It has since been revisited, cleaned up, and optimized for modern usage while preserving the core academic principles. Features \u00b6 Uses BLOSSUM62 scoring matrix for protein sequences. Uses EDNA scoring matrix for DNA sequences. Supports both global and local alignment algorithms. Handles large sequences efficiently with optimized memory usage. Provides colorful visual feedback for better understanding of the alignment process. Author \u00b6 Abhinav Mishra Email: mishraabhinav@gmail.com","title":"About"},{"location":"about.html#about-this-project","text":"This tool was first written by Abhinav Mishra during a Biological Computation course at JUIT, Solan in 2014. It has since been revisited, cleaned up, and optimized for modern usage while preserving the core academic principles.","title":"About This Project"},{"location":"about.html#features","text":"Uses BLOSSUM62 scoring matrix for protein sequences. Uses EDNA scoring matrix for DNA sequences. Supports both global and local alignment algorithms. Handles large sequences efficiently with optimized memory usage. Provides colorful visual feedback for better understanding of the alignment process.","title":"Features"},{"location":"about.html#author","text":"Abhinav Mishra Email: mishraabhinav@gmail.com","title":"Author"},{"location":"input.html","text":"Input Format \u00b6 Input files must be in standard FASTA format. Only the first sequence per file is read. FASTA headers (lines starting with '>') are skipped automatically. Example: For DNA sequences, use the following format: >sequence1 AGCTAGCTAGCTA >sequence2 GCTAGCTAGCTAG For protein sequences, use the following format: >protein1 MKTAYIAKQRQISFVKSHFSRQDILDL >protein2 MKTAAYIAKQRQISFVKSHFSRQDILDL Test Files \u00b6 Located in the files/ directory: dna1.fasta : Contains DNA sequences for testing. protein1.fasta : Contains protein sequences for testing. dna2.fasta : Contains DNA sequences for testing. protein2.fasta : Contains protein sequences for testing.","title":"Input"},{"location":"input.html#input-format","text":"Input files must be in standard FASTA format. Only the first sequence per file is read. FASTA headers (lines starting with '>') are skipped automatically. Example: For DNA sequences, use the following format: >sequence1 AGCTAGCTAGCTA >sequence2 GCTAGCTAGCTAG For protein sequences, use the following format: >protein1 MKTAYIAKQRQISFVKSHFSRQDILDL >protein2 MKTAAYIAKQRQISFVKSHFSRQDILDL","title":"Input Format"},{"location":"input.html#test-files","text":"Located in the files/ directory: dna1.fasta : Contains DNA sequences for testing. protein1.fasta : Contains protein sequences for testing. dna2.fasta : Contains DNA sequences for testing. protein2.fasta : Contains protein sequences for testing.","title":"Test Files"},{"location":"outputs.html","text":"Output Format \u00b6 The output consists of two aligned sequences printed line-by-line: Green : matched characters Red : gaps Cyan : mismatches Each output block includes the base range for easier visual indexing. Future Improvements \u00b6 Support multi-sequence alignment. Allow multiple FASTA entries. Export alignment results in standard formats (CLUSTAL, Stockholm). Web-based or GUI interface.","title":"Output"},{"location":"outputs.html#output-format","text":"The output consists of two aligned sequences printed line-by-line: Green : matched characters Red : gaps Cyan : mismatches Each output block includes the base range for easier visual indexing.","title":"Output Format"},{"location":"outputs.html#future-improvements","text":"Support multi-sequence alignment. Allow multiple FASTA entries. Export alignment results in standard formats (CLUSTAL, Stockholm). Web-based or GUI interface.","title":"Future Improvements"},{"location":"processes.html","text":"Theoretical Background \u00b6 1. Longest Common Subsequence (LCS) \u00b6 The LCS problem is solved using a dynamic programming table to compute the length and path of the longest subsequence common to both strings. The solution provides insights into evolutionary or structural similarity at a character level. Time Complexity: $O(m \\cdot n)$ Space Complexity: $O(m \\cdot n)$ Alignment Type: Character-based (not contiguous) 2. Global Alignment (Needleman-Wunsch) \u00b6 This method aligns the entire sequences using a scoring matrix initialized with gap penalties. It is ideal for full-length, homologous sequences. Time Complexity: $O(m \\cdot n)$ Uses a traceback matrix to reconstruct the alignment path. Supports scoring for matches, mismatches, and gaps. 3. Local Alignment (Smith-Waterman) \u00b6 Focuses on identifying the most similar subsequences. Suitable for aligning protein motifs or conserved regions. Time Complexity: $O(m \\cdot n)$ Incorporates zero in scoring to allow for local reset. Traceback stops when score becomes zero. Alignment Matrix and Mathematical Explanation \u00b6 1. Longest Common Subsequence (LCS) \u00b6 Goal: Find the longest subsequence common to two sequences $X = x_1x_2\\ldots x_m$ and $Y = y_1y_2\\ldots y_n$. Matrix Definition \u00b6 Let $C[i][j]$ denote the length of the LCS of the prefixes $x_1\\ldots x_i$ and $y_1\\ldots y_j$. Recurrence Relation: $$ C[i][j] = \\begin{cases} 0 & \\text{if } i = 0 \\text{ or } j = 0 \\\\ C[i-1][j-1] + 1 & \\text{if } x_i = y_j \\\\ \\max(C[i-1][j], C[i][j-1]) & \\text{otherwise} \\end{cases} $$ Backtracking Table: D : Diagonal (match) U : Up (skip from X) L : Left (skip from Y) In Code: if (x[i - 1] == y[j - 1]) { c[i][j] = c[i - 1][j - 1] + 1; b[i][j] = 'D'; } else if (c[i - 1][j] >= c[i][j - 1]) { c[i][j] = c[i - 1][j]; b[i][j] = 'U'; } else { c[i][j] = c[i][j - 1]; b[i][j] = 'L'; } 2. Global Alignment (Needleman\u2013Wunsch) \u00b6 Goal: Align full sequences $X$ and $Y$ from start to end, minimizing penalties or maximizing score. Matrix Definition \u00b6 Let $S[i][j]$ denote the optimal alignment score between $x_1\\ldots x_i$ and $y_1\\ldots y_j$. Initialization: $$ S[i][0] = i \\cdot \\text{GAP},\\quad S[0][j] = j \\cdot \\text{GAP} $$ Recurrence Relation: $$ S[i][j] = \\max \\begin{cases} S[i-1][j-1] + \\text{score}(x_i, y_j) \\ S[i-1][j] + \\text{GAP} \\ S[i][j-1] + \\text{GAP} \\end{cases} $$ where: $$ \\text{score}(x_i, y_j) = \\begin{cases} \\text{MATCH} & \\text{if } x_i = y_j \\\\ \\text{MISMATCH} & \\text{otherwise} \\end{cases} $$ Traceback: Built from a traceback[][] matrix storing 'D' , 'U' , 'L' for path recovery. 3. Local Alignment (Smith\u2013Waterman) \u00b6 Goal: Find the highest scoring local region between two sequences, ideal for detecting motifs. Matrix Definition \u00b6 Let $H[i][j]$ be the highest scoring alignment ending at $x_i, y_j$. Initialization: $$ H[i][0] = 0,\\quad H[0][j] = 0 $$ Recurrence Relation: $$ H[i][j] = \\max \\begin{cases} 0 \\ H[i-1][j-1] + \\text{score}(x_i, y_j) \\ H[i-1][j] + \\text{GAP} \\ H[i][j-1] + \\text{GAP} \\end{cases} $$ Reset to 0 allows alignment to start anywhere and stop at the best score. Traceback: Starts from the max score cell and moves until score is zero. Time and Space Complexities \u00b6 Algorithm Time Complexity Space Complexity Alignment Type LCS O(m\u00b7n) O(m\u00b7n) Character-only Global (NW) O(m\u00b7n) O(m\u00b7n) Full sequence Local (SW) O(m\u00b7n) O(m\u00b7n) Subsequence Where $m = |X|$, $n = |Y|$","title":"Theoretical Background"},{"location":"processes.html#theoretical-background","text":"","title":"Theoretical Background"},{"location":"processes.html#1-longest-common-subsequence-lcs","text":"The LCS problem is solved using a dynamic programming table to compute the length and path of the longest subsequence common to both strings. The solution provides insights into evolutionary or structural similarity at a character level. Time Complexity: $O(m \\cdot n)$ Space Complexity: $O(m \\cdot n)$ Alignment Type: Character-based (not contiguous)","title":"1. Longest Common Subsequence (LCS)"},{"location":"processes.html#2-global-alignment-needleman-wunsch","text":"This method aligns the entire sequences using a scoring matrix initialized with gap penalties. It is ideal for full-length, homologous sequences. Time Complexity: $O(m \\cdot n)$ Uses a traceback matrix to reconstruct the alignment path. Supports scoring for matches, mismatches, and gaps.","title":"2. Global Alignment (Needleman-Wunsch)"},{"location":"processes.html#3-local-alignment-smith-waterman","text":"Focuses on identifying the most similar subsequences. Suitable for aligning protein motifs or conserved regions. Time Complexity: $O(m \\cdot n)$ Incorporates zero in scoring to allow for local reset. Traceback stops when score becomes zero.","title":"3. Local Alignment (Smith-Waterman)"},{"location":"processes.html#alignment-matrix-and-mathematical-explanation","text":"","title":"Alignment Matrix and Mathematical Explanation"},{"location":"processes.html#1-longest-common-subsequence-lcs_1","text":"Goal: Find the longest subsequence common to two sequences $X = x_1x_2\\ldots x_m$ and $Y = y_1y_2\\ldots y_n$.","title":"1. Longest Common Subsequence (LCS)"},{"location":"processes.html#matrix-definition","text":"Let $C[i][j]$ denote the length of the LCS of the prefixes $x_1\\ldots x_i$ and $y_1\\ldots y_j$. Recurrence Relation: $$ C[i][j] = \\begin{cases} 0 & \\text{if } i = 0 \\text{ or } j = 0 \\\\ C[i-1][j-1] + 1 & \\text{if } x_i = y_j \\\\ \\max(C[i-1][j], C[i][j-1]) & \\text{otherwise} \\end{cases} $$ Backtracking Table: D : Diagonal (match) U : Up (skip from X) L : Left (skip from Y) In Code: if (x[i - 1] == y[j - 1]) { c[i][j] = c[i - 1][j - 1] + 1; b[i][j] = 'D'; } else if (c[i - 1][j] >= c[i][j - 1]) { c[i][j] = c[i - 1][j]; b[i][j] = 'U'; } else { c[i][j] = c[i][j - 1]; b[i][j] = 'L'; }","title":"Matrix Definition"},{"location":"processes.html#2-global-alignment-needlemanwunsch","text":"Goal: Align full sequences $X$ and $Y$ from start to end, minimizing penalties or maximizing score.","title":"2. Global Alignment (Needleman\u2013Wunsch)"},{"location":"processes.html#matrix-definition_1","text":"Let $S[i][j]$ denote the optimal alignment score between $x_1\\ldots x_i$ and $y_1\\ldots y_j$. Initialization: $$ S[i][0] = i \\cdot \\text{GAP},\\quad S[0][j] = j \\cdot \\text{GAP} $$ Recurrence Relation: $$ S[i][j] = \\max \\begin{cases} S[i-1][j-1] + \\text{score}(x_i, y_j) \\ S[i-1][j] + \\text{GAP} \\ S[i][j-1] + \\text{GAP} \\end{cases} $$ where: $$ \\text{score}(x_i, y_j) = \\begin{cases} \\text{MATCH} & \\text{if } x_i = y_j \\\\ \\text{MISMATCH} & \\text{otherwise} \\end{cases} $$ Traceback: Built from a traceback[][] matrix storing 'D' , 'U' , 'L' for path recovery.","title":"Matrix Definition"},{"location":"processes.html#3-local-alignment-smithwaterman","text":"Goal: Find the highest scoring local region between two sequences, ideal for detecting motifs.","title":"3. Local Alignment (Smith\u2013Waterman)"},{"location":"processes.html#matrix-definition_2","text":"Let $H[i][j]$ be the highest scoring alignment ending at $x_i, y_j$. Initialization: $$ H[i][0] = 0,\\quad H[0][j] = 0 $$ Recurrence Relation: $$ H[i][j] = \\max \\begin{cases} 0 \\ H[i-1][j-1] + \\text{score}(x_i, y_j) \\ H[i-1][j] + \\text{GAP} \\ H[i][j-1] + \\text{GAP} \\end{cases} $$ Reset to 0 allows alignment to start anywhere and stop at the best score. Traceback: Starts from the max score cell and moves until score is zero.","title":"Matrix Definition"},{"location":"processes.html#time-and-space-complexities","text":"Algorithm Time Complexity Space Complexity Alignment Type LCS O(m\u00b7n) O(m\u00b7n) Character-only Global (NW) O(m\u00b7n) O(m\u00b7n) Full sequence Local (SW) O(m\u00b7n) O(m\u00b7n) Subsequence Where $m = |X|$, $n = |Y|$","title":"Time and Space Complexities"}]}